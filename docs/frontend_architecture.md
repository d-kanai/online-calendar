# 🎨 Frontendアーキテクチャルール

## 🪝 Custom Hooks Pattern

### 🛡️ Custom Hooks実装チェックリスト

#### ✅ 基本設計
- [ ] 単一責任の原則に従う（1フック=1責務）
- [ ] `use`プレフィックス使用
- [ ] 100行以下に収める
- [ ] 再利用可能な設計

#### ✅ フック分類と実装
- [ ] **データ管理フック** (`use{Entity}s.ts`): API通信・状態管理・エラーハンドリング
- [ ] **操作フック** (`use{Entity}Actions.ts`): CRUD操作・ビジネスロジック・楽観的更新
- [ ] **UI状態フック** (`use{Feature}Modals.ts`): モーダル・選択・フォーム状態管理
- [ ] **副作用フック** (`use{Service}.ts`): タイマー・通知・外部サービス連携

#### ✅ フック間連携
- [ ] props drilling回避
- [ ] 循環依存なし
- [ ] 最小限の依存関係
- [ ] コンポーネントで統合設計

```
src/app/
├── auth/signin/page.tsx, auth/signup/page.tsx  # 認証ページ
├── calendar/page.tsx                           # カレンダー画面（80-100行）
├── stats/page.tsx                              # 統計画面
├── meeting/[id]/page.tsx                       # 会議詳細画面
└── layout.tsx                                  # ルートレイアウト

src/components/                                 # 共通コンポーネント
├── AppHeader.tsx, ParticipantManager.tsx       
└── ui/                                         # UIコンポーネント
```

## 🛣️ Next.js App Router実装チェックリスト

#### ✅ ページ構造設計
- [ ] 各ルートに`page.tsx`作成
- [ ] 機能別ディレクトリ（auth/, calendar/, stats/）
- [ ] 共通コンポーネントは`src/components/`に配置

#### ✅ page.tsx実装基準
- [ ] 80-100行以内に収める
- [ ] Custom Hooksでビジネスロジック分離
- [ ] `'use client'`適切使用
- [ ] 認証状態に基づくリダイレクト

#### ✅ ルーティング実装
- [ ] `useRouter().push()`でプログラマティック遷移
- [ ] `<Link>`で宣言的遷移
- [ ] 認証ガード実装（未認証→`/signin`、認証済み→`/calendar`）
- [ ] 動的ルーティング（`[id]`）の使用

#### ✅ パフォーマンス最適化
- [ ] 動的インポート使用
- [ ] メタデータAPIでSEO対策
- [ ] Client Components最小限
- [ ] Suspenseとloading.tsxでローディング状態

#### ✅ 命名規約
- [ ] 機能コンポーネント: `{ComponentName}.component.tsx`
- [ ] 共通コンポーネント: `{ComponentName}.tsx`
- [ ] 同一機能内は相対パス（`./components/...`）
- [ ] 共通リソースは絶対パス（`@/components/...`）

## 🪝 カスタムフックパターン実装チェックリスト

#### ✅ 基本実装
- [ ] ロジックとUI表示を分離
- [ ] `use`プレフィックス使用
- [ ] 単一責任の原則
- [ ] 再利用可能な設計

#### ✅ フォームフック実装
- [ ] `useForm`でフォーム状態管理
- [ ] ビジネスルールバリデーション
- [ ] 送信処理カプセル化
- [ ] エラーハンドリング実装
- [ ] フォーム初期化ロジック

#### ✅ コンポーネント実装
- [ ] カスタムフックからロジック受け取り
- [ ] UIの表示のみに集中
- [ ] props型定義明確化
- [ ] 条件分岐最小限

## 🚫 アンチパターンと推奨パターン

#### ❌ type引数で処理分岐 → ✅ 専用メソッド分離
- **単一責任の原則**: 1関数=1責務
- **if文最小化**: 条件分岐削減
- **型安全性**: 必要パラメータのみ
- **命名明確性**: 関数名から動作明確

## 🎨 Frontend Zodバリデーション実装チェックリスト

#### ✅ スキーマ定義
- [ ] Backendと同期したZodスキーマ定義
- [ ] 必須項目に適切なエラーメッセージ設定
- [ ] 文字列trim処理適用
- [ ] カスタムバリデーション（refine）実装

#### ✅ フォーム統合
- [ ] React Hook Form連携（zodResolver使用）
- [ ] エラーメッセージ日本語化
- [ ] リアルタイムバリデーション実装
- [ ] 送信前全体バリデーション

#### ✅ ビジネスルール
- [ ] Zod表現困難ルールは個別実装
- [ ] 時間重複チェック等複雑バリデーション
- [ ] エラー配列での複数エラー管理
- [ ] UI適切エラー表示

## 🛠️ React Hook Form統合チェックリスト

#### ✅ 基本設定
- [ ] `useForm`フックでフォーム状態管理
- [ ] `zodResolver`でZodスキーマ連携
- [ ] TypeScript型安全性確保
- [ ] デフォルト値適切設定

#### ✅ フォーム要素
- [ ] `register`で各入力要素登録
- [ ] エラーメッセージ表示実装
- [ ] `handleSubmit`でフォーム送信処理
- [ ] フォーム状態（errors, isSubmitting等）活用

#### ✅ パフォーマンス
- [ ] 非制御コンポーネント最適化
- [ ] 不要再レンダリング回避
- [ ] フォームリセット処理実装
- [ ] 条件付きバリデーション最適化

## ⚡ TanStack Query実装チェックリスト

#### ✅ Query Key Factory設定
- [ ] 階層的Query Key構造定義
- [ ] `queryKeys`オブジェクト一元管理
- [ ] フィルター対応Query Key設計
- [ ] TypeScript as constアサーション使用

#### ✅ データフェッチング
- [ ] `useQuery`/`useSuspenseQuery`適切選択
- [ ] エラーハンドリング実装
- [ ] staleTimeとgcTime適切設定
- [ ] 自動リフェッチ設定

#### ✅ Mutation実装
- [ ] `useMutation`でデータ更新処理
- [ ] 楽観的更新（optimistic updates）実装
- [ ] エラー時ロールバック処理
- [ ] 成功時キャッシュ無効化

#### ✅ キャッシュ管理
- [ ] `invalidateQueries`で適切無効化
- [ ] `setQueryData`でキャッシュ更新
- [ ] 関連全キャッシュ更新
- [ ] キャッシュヘルパー関数作成

## 📝 実装指針

- **チェックリスト駆動**: 上記チェックリストで品質確保
- **型安全**: TypeScript厳格モード使用
- **パフォーマンス**: 再レンダリング最小化
- **保守性**: 責務分離と明確な命名
- **テスタビリティ**: ロジック分離でテスト容易性確保

